<!doctype html> <html lang=ja > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/Joe.jl/libs/katex/katex.min.css"> <link rel=stylesheet  href="/Joe.jl/libs/highlight/github.min.css"> <link href="/Joe.jl/css/franklin.css" rel=stylesheet > <link href="/Joe.jl/css/vela.css" rel=stylesheet > <script src="/Joe.jl/libs/vela/jquery.min.js"></script> <link rel=icon  href="/Joe.jl/assets/favicon.ico"> <title>なんでもjuliaでやってみる。</title> <div class=main-nav  id=menu > <div class=flex-container > <span class=sidebar-brand > <h3 style='font-size: 25px'>機械学習の数理100問</h3> </span> </div> <nav class=sidebar-nav > <ul class=metismenu  id=metismenu  > <li><a href="/Joe.jl/index.html">トップ</a> <li><a href="" class=has-arrow >統計的機械学習の数理100問</a> <ul> <li><a href="/Joe.jl/StatisticalML/chap1/">第一章</a> <li><a href="/Joe.jl/StatisticalML/chap2/">第二章</a> <li><a href="/Joe.jl/StatisticalML/chap4/">第四章</a> </ul> <li><a href="" class=has-arrow >スパース推定100問</a> <ul> <li> </ul> </ul> </nav> </div> <main id=panel > <div class="toggle-button hamburger hamburger--spin"> <div class=hamburger-box > <div class=hamburger-inner ></div> </div> </div> <h1 class="page title">分類</h1> <hr> <div class=franklin-content ><p><div class=franklin-toc ><ol><li><a href="#ロジスティック回帰">ロジスティック回帰</a><ol><li><a href="#例29">例29</a></ol><li><a href="#ニュートンラフソン法">ニュートン・ラフソン法</a><ol><li><a href="#例31">例31</a><li><a href="#例31__2">例31</a><li><a href="#例33">例33</a></ol><li><a href="#23_線形判別と二次判別">2.3 線形判別と二次判別</a><ol><li><a href="#例35">例35</a><li><a href="#例36_fisherのあやめ">例36 &#40;Fisherのあやめ&#41;</a></ol></ol></div> <h2 id="ロジスティック回帰"><a href="#ロジスティック回帰">ロジスティック回帰</a></h2> <h3 id="例29"><a href="#例29">例29</a></h3> <p>シグモイド関数を定義しておきます。</p> <pre><code class="julia hljs">sigmoid(x::<span class=hljs-built_in >Matrix</span>, β::<span class=hljs-built_in >Vector</span>) = <span class=hljs-number >1</span> / (<span class=hljs-number >1</span> + exp(-x*β))</code></pre>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Joe, Plots
p29 = plot(xlims=(-<span class=hljs-number >10</span>,<span class=hljs-number >10</span>), xlabel=<span class=hljs-string >&quot;x&quot;</span>,ylabel=<span class=hljs-string >&quot;P(Y=1|x)&quot;</span>,
            legend=:topleft, title=<span class=hljs-string >&quot;ロジスティック曲線&quot;</span>)
x29 = expand_matrix(-<span class=hljs-number >10</span>:<span class=hljs-number >0.1</span>:<span class=hljs-number >10</span>)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> [<span class=hljs-number >0</span>, <span class=hljs-number >0.2</span>, <span class=hljs-number >0.5</span>, <span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >10</span>]
    plot!(p29, x29[:,<span class=hljs-number >2</span>], Joe.sigmoid(x29,[<span class=hljs-number >0</span>,i]),label=<span class=hljs-string >&quot;<span class=hljs-variable >$i</span>&quot;</span>)
<span class=hljs-keyword >end</span></code></pre>
<img src="/Joe.jl/assets/StatisticalML/chap2/code/output/fig2-1.svg" alt="">
<h2 id="ニュートンラフソン法"><a href="#ニュートンラフソン法">ニュートン・ラフソン法</a></h2>
<h3 id="例31"><a href="#例31">例31</a></h3>
<p><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x^2-1=0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.897438em;vertical-align:-0.08333em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >1</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span></span></span></span>を4を初期値として数値計算で解く問題。10回でどの程度近づくか。 せっかくなので、 微分をあらわに書き下すのではなくて、自動微分パッケージを使ってみることにします。 見た目が<span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>←</mo><mi>x</mi><mo>−</mo><mstyle displaystyle=true  scriptlevel=0 ><mfrac><mrow><mi>f</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo></mrow><mrow><msup><mi>f</mi><mo mathvariant=normal  lspace=0em  rspace=0em >′</mo></msup><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">x \leftarrow x - \dfrac{f(x)}{f&#x27;(x)}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >←</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:2.363em;vertical-align:-0.936em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.427em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord ><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.6778919999999999em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>という公式のまんまですね。</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Zygote
f(x) = x^<span class=hljs-number >2</span> -<span class=hljs-number >1</span>
x=<span class=hljs-number >4</span>
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10</span>
    x -= f(x)/f&#x27;(x)
    println(x)
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">2.125
1.2977941176470589
1.0341661806365605
1.0005643811996305
1.0000001591732348
1.0000000000000127
1.0
1.0
1.0
1.0
</code></pre>
<h3 id="例31__2"><a href="#例31__2">例31</a></h3>
<p>2変数関数が2つある場合。 Zygote.jlにjacobianがなかったので、ForwardDiff.jlを使ってみます。</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> ForwardDiff

f(x,y) = [x^<span class=hljs-number >2</span>+y^<span class=hljs-number >2</span>-<span class=hljs-number >1</span>, x+y]
z = [<span class=hljs-number >3</span>,<span class=hljs-number >4</span>]
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10</span>
    z -= ForwardDiff.jacobian(x-&gt;f(x[<span class=hljs-number >1</span>], x[<span class=hljs-number >2</span>]),z) \ f(z[<span class=hljs-number >1</span>],z[<span class=hljs-number >2</span>])
    println(z)
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">[-13.000000000000004, 13.000000000000002]
[-6.519230769230771, 6.519230769230771]
[-3.297963467211255, 3.297963467211255]
[-1.7247860905930625, 1.7247860905930625]
[-1.0073385555621193, 1.0073385555621193]
[-0.7518480044063836, 0.7518480044063836]
[-0.7084380190454468, 0.7084380190454468]
[-0.7071080319623313, 0.7071080319623313]
[-0.7071067811876538, 0.7071067811876538]
[-0.7071067811865475, 0.7071067811865475]
</code></pre>
<h3 id="例33"><a href="#例33">例33</a></h3>
<p>最尤推定によりロジスティック回帰を行う問題。 <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >∇</mi><mi>l</mi><mo stretchy=false >(</mo><msub><mi>β</mi><mn>0</mn></msub><mo separator=true >,</mo><mi>β</mi><mo stretchy=false >)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\nabla l(\beta_0, \beta) = 0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >∇</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span></span></span></span>を求める問題を解いてみる。 素直に<code>1 ./ &#40;1 .&#43; exp.&#40;X*β&#41;&#41;</code>と書いたりfor文を回しても良いと思いますが。）</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Joe, Random, LinearAlgebra
N=<span class=hljs-number >1000</span>; p=<span class=hljs-number >2</span>; Random.seed!(<span class=hljs-number >12</span>)
X = expand_matrix(randn(N,p))
β = randn(p+<span class=hljs-number >1</span>)
prob = @. <span class=hljs-number >1</span>/(<span class=hljs-number >1</span> + exp($*(X,β)))
threshold=<span class=hljs-number >0.5</span>
y = ifelse.(rand(N) .&gt; prob,<span class=hljs-number >1</span>,-<span class=hljs-number >1</span>) <span class=hljs-comment ># ここまでデータ生成</span>
<span class=hljs-meta >@show</span> y β</code></pre><pre><code class="plaintext hljs">y = [-1, 1, -1, -1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, -1, -1, -1, -1, 1, 1, -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, 1, -1, 1, 1, 1, -1, -1, 1, 1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, -1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, 1, 1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, -1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, -1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, 1, 1, -1, -1, 1, 1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, -1, 1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, 1, -1, 1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, 1, -1, -1, 1, -1, -1, 1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, -1, 1, -1, -1, -1, 1, 1, -1, -1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, -1, 1, 1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, -1, -1, -1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, 1, -1, 1, 1, -1, -1, 1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, -1, 1, -1, 1, -1, 1, -1, -1, -1, -1, 1, -1, -1, -1, 1, 1, -1, -1, -1, 1, 1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, -1, 1, -1, 1, 1, -1, 1, 1, -1, 1, 1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, -1, 1, 1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, 1, -1, -1, -1, -1, 1, 1, -1, -1, -1, 1, -1, -1, -1, 1, 1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, -1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, -1, 1, 1, -1, -1, -1, 1, -1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, 1, 1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, 1, 1, -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, -1, 1, -1, 1, -1, -1, -1, -1, 1, 1, 1, -1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, 1, 1, 1, -1, -1, -1, 1, 1]
β = [-0.4162625490184776, -1.342542682700591, 0.09043723155291195]
</code></pre>
<p>せっかくなのでデータを可視化してみます。</p>
<pre><code class="julia hljs">data1 = X[y .== <span class=hljs-number >1</span>, <span class=hljs-number >2</span>:<span class=hljs-number >3</span>]
data2 = X[y .== -<span class=hljs-number >1</span>, <span class=hljs-number >2</span>:<span class=hljs-number >3</span>]
p33=scatter(data1[:,<span class=hljs-number >1</span>],data1[:,<span class=hljs-number >2</span>],ylims=(-<span class=hljs-number >5</span>,<span class=hljs-number >5</span>),marker=:auto, label=<span class=hljs-string >&quot;y=1&quot;</span>)
scatter!(data2[:,<span class=hljs-number >1</span>],data2[:,<span class=hljs-number >2</span>],marker=:auto,label=<span class=hljs-string >&quot;y=-1&quot;</span>)
plot!(x-&gt; -β[<span class=hljs-number >1</span>]/β[<span class=hljs-number >3</span>] - β[<span class=hljs-number >2</span>]/β[<span class=hljs-number >3</span>]*x, label=<span class=hljs-string >&quot;β&quot;</span>)</code></pre>
<img src="/Joe.jl/assets/StatisticalML/chap2/code/output/fig2-2.svg" alt="">
<pre><code class="julia hljs">γ = randn(p+<span class=hljs-number >1</span>)
γ<span class=hljs-number >2</span>=copy(γ)
<span class=hljs-meta >@show</span> γ

W(v::<span class=hljs-built_in >Vector</span>) = @.(v/(<span class=hljs-number >1</span>+ v)^<span class=hljs-number >2</span>) |&gt; diagm
t = <span class=hljs-literal >true</span>
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10</span>
    <span class=hljs-keyword >global</span> γ
    s=X*γ
    v = @. exp(-y*s)
    u = @. y*v/(<span class=hljs-number >1</span>+v)
    γ += ((X&#x27;*W(v)*X) \ X&#x27;) * u
    <span class=hljs-comment >#δ&#x27;*δ &lt; 0.001 &amp;&amp; (t = false)</span>
    <span class=hljs-meta >@show</span> γ
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">γ = [-0.8771716229486168, -0.2526647989249558, 0.03370522564888635]
γ = [-0.3160894896511689, -1.0914139744134563, -0.15348497886015344]
γ = [-0.379765402697948, -1.25496756611813, -0.17121180318377313]
γ = [-0.3846741826784717, -1.2691296918419084, -0.17335517332850547]
γ = [-0.3847054570036605, -1.2692254442251742, -0.17337199438178288]
γ = [-0.3847054583679146, -1.2692254485603638, -0.17337199521205846]
γ = [-0.3847054583679146, -1.2692254485603638, -0.17337199521205846]
γ = [-0.3847054583679146, -1.2692254485603638, -0.17337199521205846]
γ = [-0.3847054583679146, -1.2692254485603638, -0.17337199521205846]
γ = [-0.3847054583679146, -1.2692254485603638, -0.17337199521205846]
γ = [-0.3847054583679146, -1.2692254485603638, -0.17337199521205846]
</code></pre>
<p>横着をして、自動微分を使って計算してみます。</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Zygote, LinearAlgebra
l(γ,X=X,y=y) = sum(@. log( <span class=hljs-number >1</span> /(<span class=hljs-number >1</span>+exp(*($*(X,γ),-y))))) <span class=hljs-comment >#対数尤度関数</span>

<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10</span>
    <span class=hljs-keyword >global</span> γ,γ<span class=hljs-number >2</span>
    δ =  Zygote.hessian(l,γ) \ l&#x27;(γ)
    <span class=hljs-meta >@show</span> norm(δ)^<span class=hljs-number >2</span>
    γ<span class=hljs-number >2</span> -= δ
    <span class=hljs-meta >@show</span> γ<span class=hljs-number >2</span>
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">norm(δ) ^ 2 = 1.74613568400146e-32
γ2 = [-0.8771716229486168, -0.2526647989249557, 0.03370522564888639]
norm(δ) ^ 2 = 1.74613568400146e-32
γ2 = [-0.8771716229486168, -0.2526647989249556, 0.03370522564888642]
norm(δ) ^ 2 = 1.74613568400146e-32
γ2 = [-0.8771716229486168, -0.25266479892495547, 0.03370522564888646]
norm(δ) ^ 2 = 1.74613568400146e-32
γ2 = [-0.8771716229486168, -0.25266479892495536, 0.03370522564888649]
norm(δ) ^ 2 = 1.74613568400146e-32
γ2 = [-0.8771716229486168, -0.25266479892495525, 0.033705225648886526]
norm(δ) ^ 2 = 1.74613568400146e-32
γ2 = [-0.8771716229486168, -0.25266479892495514, 0.03370522564888656]
norm(δ) ^ 2 = 1.74613568400146e-32
γ2 = [-0.8771716229486168, -0.252664798924955, 0.033705225648886596]
norm(δ) ^ 2 = 1.74613568400146e-32
γ2 = [-0.8771716229486168, -0.2526647989249549, 0.03370522564888663]
norm(δ) ^ 2 = 1.74613568400146e-32
γ2 = [-0.8771716229486168, -0.2526647989249548, 0.033705225648886665]
norm(δ) ^ 2 = 1.74613568400146e-32
γ2 = [-0.8771716229486168, -0.2526647989249547, 0.0337052256488867]
</code></pre>
<h2 id="23_線形判別と二次判別"><a href="#23_線形判別と二次判別">2.3 線形判別と二次判別</a></h2>
<h3 id="例35"><a href="#例35">例35</a></h3>
<p>まずは与えられた平均と分散共分散行列から二次元正規分布のデータを2種類生成します。</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Distributions, Random,Plots, LinearAlgebra, Parameters
μ₁=[<span class=hljs-number >2</span>,<span class=hljs-number >2</span>];  Σ₁ = [<span class=hljs-number >2</span> <span class=hljs-number >0</span>; <span class=hljs-number >0</span> <span class=hljs-number >2</span>]
μ₂=[-<span class=hljs-number >3</span>,-<span class=hljs-number >3</span>]; Σ₂ = [<span class=hljs-number >1</span> -<span class=hljs-number >0.8</span>; -<span class=hljs-number >0.8</span> <span class=hljs-number >1</span>]

N = <span class=hljs-number >100</span>;Random.seed!(<span class=hljs-number >123</span>)
data1 = rand(MvNormal(μ₁,Σ₁),<span class=hljs-number >100</span>) |&gt; transpose
data2 = rand(MvNormal(μ₂,Σ₂),<span class=hljs-number >100</span>) |&gt; transpose
p35 = scatter(data1[:,<span class=hljs-number >1</span>],data1[:,<span class=hljs-number >2</span>])
scatter!(p35, data2[:,<span class=hljs-number >1</span>],data2[:,<span class=hljs-number >2</span>])</code></pre>
<img src="/Joe.jl/assets/StatisticalML/chap2/code/output/fig2-3.svg" alt="">
<p>ここまでデータの生成。 生成したデータから平均と分散共分散行列を計算する。</p>
<pre><code class="julia hljs">μ̂₁ = mean(data1,dims=<span class=hljs-number >1</span>)&#x27;; Σ̂₁ = cov(data1,dims=<span class=hljs-number >1</span>);
μ̂₂ = mean(data2,dims=<span class=hljs-number >1</span>)&#x27; ; Σ̂₂ = cov(data2,dims=<span class=hljs-number >1</span>);</code></pre>
<p><div class=warning ><div class=title >😕 Warning&#33;</div>
<div class=content >mean関数で行列の列方向の平均をとる時、得られるデータは二次元の横ベクトルになっている。<br />縦ベクトルとして扱いたいので、転置している。</div></div> それぞれの分布の情報を複合型にまとめておく。</p>
<pre><code class="julia hljs"><span class=hljs-meta >@with_kw</span> <span class=hljs-keyword >struct</span> mvnormal
    μ::<span class=hljs-built_in >Array</span> <span class=hljs-comment ># 平均</span>
    Σ::<span class=hljs-built_in >Matrix</span> <span class=hljs-comment ># 分散共分散行列</span>
    invΣ::<span class=hljs-built_in >Array</span> = inv(Σ) <span class=hljs-comment ># 分散共分散行列の逆行列</span>
    detΣ = det(Σ) <span class=hljs-comment ># 分散共分散行列の行列式</span>
<span class=hljs-keyword >end</span></code></pre>
<p>また、多変量正規分布の対数尤度を取得する関数を以下のように定義する。 可変長引数を使うことで、データが3次元以上の場合にも拡張している。</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> logMvNormal(parameter::mvnormal,x...)
    data = collect(x)
    <span class=hljs-meta >@unpack</span> μ,invΣ,detΣ = parameter
    a = <span class=hljs-number >0.5</span>*(data-μ)&#x27; * invΣ * (data-μ)
    a[<span class=hljs-number >1</span>] - log(detΣ)
<span class=hljs-keyword >end</span></code></pre>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Joe: mvnormal, logMvNormal
param1=mvnormal(μ= μ̂₁,Σ = Σ̂₁);param2=mvnormal(μ = μ̂₂,Σ = Σ̂₂)</code></pre><pre><code class="plaintext hljs">Joe.mvnormal
  μ: Array{Float64}((2, 1)) [-3.047955710310618; -2.932266562954253]
  Σ: Array{Float64}((2, 2)) [1.0429822697740516 -0.7599159692872768; -0.7599159692872768 0.9117178328466301]
  invΣ: Array{Float64}((2, 2)) [2.441447895452185 2.0349445597046123; 2.0349445597046123 2.792954986504203]
  detΣ: Float64 0.37343325431803626
</code></pre>
<p>それぞれの正規分布の平均と分散共分散行列のを与えたときの 対数尤度の差をとって、コンター図にする。&#40;二次判別&#41;</p>
<pre><code class="julia hljs">hanbetsu(x,y) = logMvNormal(param1,x,y) - logMvNormal(param2,x,y)
x35=-<span class=hljs-number >5</span>:<span class=hljs-number >0.1</span>:<span class=hljs-number >5</span>;
y35=-<span class=hljs-number >5</span>:<span class=hljs-number >0.1</span>:<span class=hljs-number >5</span>;
scatter(data1[:,<span class=hljs-number >1</span>],data1[:,<span class=hljs-number >2</span>])
scatter!( data2[:,<span class=hljs-number >1</span>],data2[:,<span class=hljs-number >2</span>])
p35_2=contour!(x35,y35, hanbetsu.(x35,y35&#x27;), title=<span class=hljs-string >&quot;QDA&quot;</span>)</code></pre>
<p><img src="/Joe.jl/assets/StatisticalML/chap2/code/output/fig2-4.svg" alt=""> 線形判別を行う場合は、分散共分散行列が等しいことを仮定する。 data1とdata2を、それぞれ中心化後に統合したデータセットについて、 新たな分散共分散行列を求めることにする。 後は</p>
<pre><code class="julia hljs">Σ_L =  vcat(data1 .- μ̂₁&#x27; , data2 .- μ̂₂&#x27;) |&gt; cov
param1_L=mvnormal(μ= μ̂₁,Σ =Σ_L );param2_L=mvnormal(μ = μ̂₂,Σ = Σ_L)
hanbetsu_L(x,y) = logMvNormal(param1_L,x,y) - logMvNormal(param2_L,x,y)
p35_3=contour!(p35,x35,y35, hanbetsu_L.(x35,y35&#x27;), title=<span class=hljs-string >&quot;LDA&quot;</span>)</code></pre>
<img src="/Joe.jl/assets/StatisticalML/chap2/code/output/fig2-5.svg" alt="">
<h3 id="例36_fisherのあやめ"><a href="#例36_fisherのあやめ">例36 &#40;Fisherのあやめ&#41;</a></h3>
<p>まずRDatasetsからirisのデータセットを読み込む。</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> RDatasets, StatsBase
<span class=hljs-keyword >using</span> Joe:mvnormal, logMvNormal
iris = dataset(<span class=hljs-string >&quot;datasets&quot;</span>,<span class=hljs-string >&quot;iris&quot;</span>)
x = iris[!,<span class=hljs-number >1</span>:<span class=hljs-number >4</span>]
y = iris.Species
n = length(y)
index = sample(<span class=hljs-number >1</span>:n,n,replace=<span class=hljs-literal >false</span>); <span class=hljs-comment >#ランダムなインデックスを作り</span>
train=index[<span class=hljs-keyword >begin</span>:<span class=hljs-built_in >Int</span>(n/<span class=hljs-number >2</span>)];<span class=hljs-comment ># 学習用とテスト用にインデックスを分ける。</span>
text = index[<span class=hljs-built_in >Int</span>(n/<span class=hljs-number >2</span>)+<span class=hljs-number >1</span>:<span class=hljs-keyword >end</span>];
X = x[train,:] |&gt; <span class=hljs-built_in >Matrix</span>
Y = y[train];</code></pre><pre><code class="plaintext hljs">ArgumentError: Package StatsBase not found in current path:
- Run `import Pkg; Pkg.add(&quot;StatsBase&quot;)` to install the StatsBase package.

</code></pre>
<p>params &#61; mvnormal&#91;&#93; あやめの種類ごとに平均と分散共分散行列 for species in unique&#40;y&#41;     xx &#61; X&#91;y&#61;&#61;species,:&#93;     push&#33;&#40;μ, mean&#40;xx,dims&#61;1&#41;&#41;     push&#33;&#40;Σ, cov&#40;xx,dims&#61;1&#41;&#41; end</p>
</p>
<div class=page-foot >
  <div class=copyright >
    &copy; Kei Hanafusa. Last modified: December 22, 2020. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
  </main> 
  <script src="/Joe.jl/libs/vela/metisMenu.min.js"></script>
  <script src="/Joe.jl/libs/vela/slideout.min.js"></script>